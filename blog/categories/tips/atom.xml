<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tips | Cheraq.com]]></title>
  <link href="http://mjfathinia.github.com/blog/categories/tips/atom.xml" rel="self"/>
  <link href="http://mjfathinia.github.com/"/>
  <updated>2013-05-10T10:47:30+04:00</updated>
  <id>http://mjfathinia.github.com/</id>
  <author>
    <name><![CDATA[Mohammad J. Fathinia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Extension Methods in .NET]]></title>
    <link href="http://mjfathinia.github.com/blog/2011/05/26/extension-methods-in-net/"/>
    <updated>2011-05-26T16:19:00+04:00</updated>
    <id>http://mjfathinia.github.com/blog/2011/05/26/extension-methods-in-net</id>
    <content type="html"><![CDATA[<p>Sometimes, you need to add new methods to a type, for example, when you are developing a website, you need to use <code>HttpUtility.HtmlEncode()</code> function to encode html and then dump it to screen. For example if you have a class called <code>Post</code> and this class has a property called <code>PostTitle</code>, then you need to do like below:</p>

<pre><code>Post p = Post.LoadPost();
ltPostBody.Text = HttpUtility.HtmlEncode(p.PostTitle);
</code></pre>

<p>But if we have a method in string class that does this for us, then life will be easier and we could use something like below:</p>

<pre><code>ltPostBody.Text = p.PostTitle.HtmlEncode();
</code></pre>

<p>One way to do this is to modify the <code>Post</code> class and change the type of <code>PostTitle</code> to a derived type that has <code>HtmlEncode</code> method. But this is not a solution. What if you couldn&#8217;t modify the <code>Post</code> class? Or what if you couldn&#8217;t create new derived type because it is sealed by author. Or lots of other scenarios.</p>

<p>The simple solution is, using extension methods. What is it? <a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">MSDN</a> says:</p>

<blockquote><p>Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</p></blockquote>

<p>The advantage of extension methods are, they will be available on all objects derived from that type. So if you add an extension method to <code>string</code> class, then it will be available on all string objects. Let&#8217;s see how we will implement extension methods. Again <a href="http://msdn.microsoft.com/en-us/library/bb383977.aspx">MSDN</a> says:</p>

<blockquote><p>Extension methods are defined as static methods but are called by using instance method syntax. Their first parameter specifies which type the method operates on, and the parameter is preceded by the <code>this</code> modifier. Extension methods are only in scope when you explicitly import the namespace into your source code with a <code>using</code> directive.</p></blockquote>

<p>Let write our own extension method. First we will add new class as below:</p>

<pre><code>namespace Cheraq.Extensions
{
    public static class StringExtensions
    {
        // our methods will be defined here
    }
}
</code></pre>

<p>Now we will define our extension method:</p>

<pre><code>public static string HTMLEncode(this string phrase)
{
    return HttpUtility.HtmlEncode(phrase);
}
</code></pre>

<p>First of all, our method should be <code>static</code>. Also if you see the parameter, it is so strange. The first parameter should be defined as below:</p>

<pre><code>this type-that-you-want-to-add-extension-method-to-it parameter-name
</code></pre>

<p>After that we will define our implementation of the function. When we want to use the function, we need to add using directive to import the namespace. When you import the namespace, the extension method will be available for all object derived from that type. Below image shows our extension method on the auto-complete window. You can see the icon of the extension method is different.</p>

<p><img src="http://cheraq.com/wp-content/uploads/2011/05/ext-1.jpg" alt="HTMLEncode is an extension method, so it got a different icon." /></p>

<p>The usage of extension method is same as normal method of that type. You can even add extension method to sealed class. But this will not violate the principal of encapsulation, because extended methods cannot access private variable and methods in the type they are extending. Below you can find summary of some facts about extension methods:</p>

<ul>
<li>Extension methods can only access private variable and methods in the type they are extending!</li>
<li>You cannot use them to override methods of a class or interface</li>
<li>They have lower priority than instance methods defined in the type itself. In other words, compiler first looks into the instance methods; if did not find any method with same signature, then it will search in extension methods</li>
<li>Extension methods are brought into scope at the namespace level</li>
<li>If you do not have access to the code of the type that you are extending, then it is better to keep in mind that changes in that type might break the extension method</li>
</ul>

]]></content>
  </entry>
  
</feed>
